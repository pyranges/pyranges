---
title: "PyRanges documentation"
author: "Endre Bakken Stovner"
date: "`r Sys.Date()`"
site: "bookdown::bookdown_site"
output:
  bookdown::gitbook: default
documentclass: book
---

# Introduction to PyRanges

PyRanges are collections of intervals that support comparison operations (like
overlap and intersect) and other methods that are useful for genomic
analyses. The ranges can have an arbitrary number of meta-data fields, i.e.
columns associated with them.

The data in PyRanges objects are stored in a pandas dataframe. This means the
vast Python ecosystem for high-performance scientific computing is available to
manipulate the data in PyRanges-objects.


```{python tidy=FALSE}
import pyranges as pr
from pyranges import PyRanges

import pandas as pd

from io import StringIO

f1 = """Chromosome Start End Score Strand
chr1 4 7 23.8 +
chr1 6 11 0.13 -
chr2 0 14 42.42 +"""

df1 = pd.read_csv(StringIO(f1), sep="\s+")

gr1 = PyRanges(df1)
```

Now we can subset the PyRange in various ways:

```{python}
print(gr1)
print(gr1["chr1", 0:5])

print(gr1["chr1", "-", 6:100])

print(gr1.Score)
```

And we can perform comparison operations with two PyRanges:

```{python}
f2 = """Chromosome Start End Score Strand
chr1 5 6 -0.01 -
chr1 9 12 200 +
chr3 0 14 21.21 -"""

df2 = pd.read_csv(StringIO(f2), sep="\s+")

gr2 = PyRanges(df2)

print(gr2)

print(gr1.intersect(gr2, strandedness="opposite"))

print(gr1.intersect(gr2, strandedness=False))

```

There are also convenience methods for single PyRanges:

```{python}
print(gr1.merge())
```

The underlying dataframe can always be accessed:

```{python}
print(gr1.df)
```
## Loading/Creating PyRanges

A PyRanges object can be built in three ways:

1. from a Pandas dataframe
2. using the PyRanges constructor with the chromosomes, starts and ends (and optionally strands), individually.
3. using one of the custom reader functions for genomic data (`read_bed`, `read_bam` or `read_gtf`)

######## Using a DataFrame {-}

If you instantiate a PyRanges object from a dataframe, the dataframe should at
least contain the columns Chromosome, Start and End. A column called Strand is
optional. Any other columns in the dataframe are treated as metadata.

```{python tidy=FALSE}

import pandas as pd
import pyranges as pr

chipseq = pr.get_example_path("chipseq.bed")

df = pd.read_csv(chipseq, header=None, names="Chromosome Start End Name Score Strand".split(), sep="\t")

print(df.head(2))
print(df.tail(2))

print(pr.PyRanges(df))
```

######## Using constructor keywords {-}

The other way to instantiate a PyRanges object is to use the constructor with keywords:

```{python tidy=FALSE}
gr = pr.PyRanges(chromosomes=df.Chromosome, starts=df.Start, ends=df.End)
print(gr)
```

It is possible to make PyRanges objects out of basic Python datatypes:

```{python tidy=FALSE}
gr = pr.PyRanges(chromosomes="chr1", strands="+", starts=[0, 1, 2], ends=(3, 4, 5))
print(gr)

gr = pr.PyRanges(chromosomes="chr1 chr2 chr3".split(), strands="+ - +".split(), starts=[0, 1, 2], ends=(3, 4, 5))
print(gr)
```

######## Using `read_bed`, `read_gtf` or `read_bam` {-}

The pyranges library can create PyRanges from three common file formats, namely gtf, bed and bam [^].

```{python tidy=FALSE}
ensembl_path = pr.get_example_path("ensembl.gtf")
gr = pr.read_gtf(ensembl_path)
print(gr)
```

[^]: PyRanges uses the pysam library which requires that the bam file must have an index.

## Writing PyRanges to disk

The PyRanges can be written to several formats, namely csv, gtf and bigwig.

If no path-argument is given, the string representation of the data is written.
(It may potentially be very large.)

```{python tidy=FALSE}
import pyranges as pr
import pyranges_db as pr_db
gr = pr.data.aorta()

gr.out.gtf("aorta.gtf")

print(gr[:10000].out.gtf())
```

The bigwig writer needs to know the chromosome sizes. You can fetch these using
the pyranges database functions.

```{python tidy=FALSE}
chromsizes = pr_db.ucsc.chromosome_sizes("hg19")
gr.out.bigwig("aorta.bw", chromsizes)
```

If you want to write one bigwig for each strand, you need to do it manually.

```{python tidy=FALSE}
gr["+"].out.bigwig("aorta_plus.bw", chromsizes)
gr["-"].out.bigwig("aorta_minus.bw", chromsizes)
```
---
title: "Subsetting PyRanges"
---

## Subsetting PyRanges

There are many ways to subset a PyRanges object. Each returns a new PyRanges object and does not change the old one.

```{python}

import pyranges as pr

gr = pr.data.chipseq()
print(gr)
```


Chromosome only


```{python tidy=FALSE}

print(gr["chrX"])
```

Chromosome and Strand


```{python tidy=FALSE}

print(gr["chrX", "-"])
```

Chromosome and Slice


```{python tidy=FALSE}

print(gr["chrX", 150000000:160000000])
```

Chromosome, Strand and Slice


```{python tidy=FALSE}

print(gr["chrX", "-", 150000000:160000000])
```

Slice

Only using slices returns all ranges from all chromosomes and strands within those coordinates.

```{python tidy=FALSE}

print(gr[0:100000])
```

Strand


```{python tidy=FALSE}

print(gr["+"])
```

Slice and Strand


```{python tidy=FALSE}

print(gr["+", 0:100000])
```
## Manipulating the data in PyRanges

PyRanges is a thin wrapper around genomic data contained in pandas dataframes.
This dataframe is accessible with the df attribute of the PyRanges object.

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.chipseq()
print(gr)
print(gr.df.head(5))
```

To access a column of this dataframe, you can ask for the name directly from the
PyRanges object.

```{python tidy=FALSE}
print(gr.Start.head())
```

You can directly insert a column by setting the attribute on the PyRanges object:

```{python tidy=FALSE}
gr.stupid_example = "Hi There!"
print(gr)
gr.df.drop("stupid_example", axis=1, inplace=True)
print(gr)
```

All columns except Chromosome, Start, End and Strand can be changed in any way
you please and more metadata-columns can be added by setting it on the PyRanges
object. If you wish to change the Chromosome, Start, End and Strand columns you
should make a copy of the data from the PyRanges object and use it to
instantiate a new PyRanges object.

```{python tidy=FALSE}
import pandas as pd
gr.Name = gr.Chromosome.astype(str) + "_" + pd.Series(range(len(gr))).astype(str)
print(gr)
```
## Concatenating PyRanges

A list of PyRanges can be concatenated by using the concat function:

```{python tidy=FALSE}
import pyranges as pr

import pandas as pd

gr1 = pr.data.f1()
gr2 = pr.data.f2()

print(gr1)

print(gr2)

concatted = pr.concat([gr1, gr2, gr1])

print(concatted)
```

## Piping PyRanges

The PyRanges API supports chaining operations out of the box.

To set a new column in a PyRanges you would use the `assign` method and for subsetting you would use the `subset` method.

```{python tidy=FALSE}
import pyranges as pr

import pandas as pd

exons = pr.data.exons()
cpg = pr.data.cpg()

cpg.join(exons.unstrand()).subset(lambda df: df.CpG > 25)[["CpG"]].assign(lambda df: df.CpG % 10, "CpGDecile")["chrX"].slack(500)
```

To debug pipelines, you can use the experimental `pr.sandbox.Debug()`. Since the debugging context-manager reads source files, it needs to be used in a file, not a REPL. See [piedpiper](https://github.com/endrebak/piedpiper) for more info.

```
import pyranges as pr
from pyranges.sandbox import Debug as D

exons = pr.data.exons()
cpg = pr.data.cpg()

with D():
    cpg.join(exons.unstrand()).subset(lambda df: df.CpG > 25)[["CpG"]].assign(lambda df: df.CpG % 10, "CpGDecile")["chrX"].slack(500)
## Start data:
## +--------------+-----------+-----------+-----------+
## | Chromosome   | Start     | End       | CpG       |
## | (category)   | (int64)   | (int64)   | (int64)   |
## |--------------+-----------+-----------+-----------|
## | chrX         | 64181     | 64793     | 62        |
## | chrX         | 69133     | 70029     | 100       |
## | chrX         | 148685    | 149461    | 85        |
## | ...          | ...       | ...       | ...       |
## | chrY         | 28773315  | 28773544  | 25        |
## | chrY         | 59213794  | 59214183  | 36        |
## | chrY         | 59349266  | 59349574  | 29        |
## +--------------+-----------+-----------+-----------+
## PyRanges object has 1077 sequences from 2 chromosomes.
##
## .join(exons.unstrand())
##
## +--------------+-----------+-----------+-----------+-----------+-----------+---------------------------------------+-----------+
## | Chromosome   | Start     | End       | CpG       | Start_b   | End_b     | Name                                  | Score     |
## | (category)   | (int64)   | (int64)   | (int64)   | (int64)   | (int64)   | (object)                              | (int64)   |
## |--------------+-----------+-----------+-----------+-----------+-----------+---------------------------------------+-----------|
## | chrX         | 584563    | 585326    | 66        | 585078    | 585337    | NM_000451_exon_0_0_chrX_585079_f      | 0         |
## | chrX         | 1510501   | 1511838   | 173       | 1510791   | 1511039   | NM_001636_exon_3_0_chrX_1510792_r     | 0         |
## | chrX         | 1553851   | 1554115   | 20        | 1553914   | 1553976   | NM_004192_exon_8_0_chrX_1553915_r     | 0         |
## | ...          | ...       | ...       | ...       | ...       | ...       | ...                                   | ...       |
## | chrY         | 15591259  | 15591720  | 33        | 15591393  | 15592550  | NR_047599_exon_28_0_chrY_15591394_r   | 0         |
## | chrY         | 16941822  | 16942188  | 32        | 16941609  | 16942399  | NM_014893_exon_4_0_chrY_16941610_f    | 0         |
## | chrY         | 26979889  | 26980116  | 21        | 26979966  | 26980276  | NM_001005375_exon_0_0_chrY_26979967_f | 0         |
## +--------------+-----------+-----------+-----------+-----------+-----------+---------------------------------------+-----------+
## PyRanges object has 79 sequences from 2 chromosomes.
##
## .subset(lambda df: df.CpG > 25)
##
## +--------------+-----------+-----------+-----------+-----------+-----------+----------------------------------------+-----------+
## | Chromosome   | Start     | End       | CpG       | Start_b   | End_b     | Name                                   | Score     |
## | (category)   | (int64)   | (int64)   | (int64)   | (int64)   | (int64)   | (object)                               | (int64)   |
## |--------------+-----------+-----------+-----------+-----------+-----------+----------------------------------------+-----------|
## | chrX         | 584563    | 585326    | 66        | 585078    | 585337    | NM_000451_exon_0_0_chrX_585079_f       | 0         |
## | chrX         | 1510501   | 1511838   | 173       | 1510791   | 1511039   | NM_001636_exon_3_0_chrX_1510792_r      | 0         |
## | chrX         | 2846195   | 2847511   | 92        | 2847272   | 2847416   | NM_001669_exon_9_0_chrX_2847273_r      | 0         |
## | ...          | ...       | ...       | ...       | ...       | ...       | ...                                    | ...       |
## | chrY         | 15591259  | 15591720  | 33        | 15591393  | 15592550  | NM_001258269_exon_29_0_chrY_15591394_r | 0         |
## | chrY         | 15591259  | 15591720  | 33        | 15591393  | 15592550  | NR_047599_exon_28_0_chrY_15591394_r    | 0         |
## | chrY         | 16941822  | 16942188  | 32        | 16941609  | 16942399  | NM_014893_exon_4_0_chrY_16941610_f     | 0         |
## +--------------+-----------+-----------+-----------+-----------+-----------+----------------------------------------+-----------+
## PyRanges object has 68 sequences from 2 chromosomes.
##
## [["CpG"]]
##
## +--------------+-----------+-----------+-----------+
## | Chromosome   | Start     | End       | CpG       |
## | (category)   | (int64)   | (int64)   | (int64)   |
## |--------------+-----------+-----------+-----------|
## | chrX         | 584563    | 585326    | 66        |
## | chrX         | 1510501   | 1511838   | 173       |
## | chrX         | 2846195   | 2847511   | 92        |
## | ...          | ...       | ...       | ...       |
## | chrY         | 15591259  | 15591720  | 33        |
## | chrY         | 15591259  | 15591720  | 33        |
## | chrY         | 16941822  | 16942188  | 32        |
## +--------------+-----------+-----------+-----------+
## PyRanges object has 68 sequences from 2 chromosomes.
##
## .assign(lambda df: df.CpG % 10, "CpGDecile")
##
## +--------------+-----------+-----------+-----------+-------------+
## | Chromosome   | Start     | End       | CpG       | CpGDecile   |
## | (category)   | (int64)   | (int64)   | (int64)   | (int64)     |
## |--------------+-----------+-----------+-----------+-------------|
## | chrX         | 584563    | 585326    | 66        | 6           |
## | chrX         | 1510501   | 1511838   | 173       | 3           |
## | chrX         | 2846195   | 2847511   | 92        | 2           |
## | ...          | ...       | ...       | ...       | ...         |
## | chrY         | 15591259  | 15591720  | 33        | 3           |
## | chrY         | 15591259  | 15591720  | 33        | 3           |
## | chrY         | 16941822  | 16942188  | 32        | 2           |
## +--------------+-----------+-----------+-----------+-------------+
## PyRanges object has 68 sequences from 2 chromosomes.
##
## ["chrX"]
##
## +--------------+-----------+-----------+-----------+-------------+
## | Chromosome   | Start     | End       | CpG       | CpGDecile   |
## | (category)   | (int64)   | (int64)   | (int64)   | (int64)     |
## |--------------+-----------+-----------+-----------+-------------|
## | chrX         | 584563    | 585326    | 66        | 6           |
## | chrX         | 1510501   | 1511838   | 173       | 3           |
## | chrX         | 2846195   | 2847511   | 92        | 2           |
## | ...          | ...       | ...       | ...       | ...         |
## | chrX         | 153284685 | 153285655 | 94        | 4           |
## | chrX         | 153598874 | 153600604 | 164       | 4           |
## | chrX         | 153990840 | 153991831 | 105       | 5           |
## +--------------+-----------+-----------+-----------+-------------+
## PyRanges object has 61 sequences from 1 chromosomes.
##
## .slack(500)
##
## +--------------+-----------+-----------+-----------+-------------+
## | Chromosome   | Start     | End       | CpG       | CpGDecile   |
## | (category)   | (int64)   | (int64)   | (int64)   | (int64)     |
## |--------------+-----------+-----------+-----------+-------------|
## | chrX         | 584063    | 585826    | 66        | 6           |
## | chrX         | 1510001   | 1512338   | 173       | 3           |
## | chrX         | 2845695   | 2848011   | 92        | 2           |
## | ...          | ...       | ...       | ...       | ...         |
## | chrX         | 153284185 | 153286155 | 94        | 4           |
## | chrX         | 153598374 | 153601104 | 164       | 4           |
## | chrX         | 153990340 | 153992331 | 105       | 5           |
## +--------------+-----------+-----------+-----------+-------------+
## PyRanges object has 61 sequences from 1 chromosomes.
##
## [exons.py:7]
```

## Iterating over PyRanges

PyRanges can be iterated over by a simple for loop, and the data is guaranteed
to come back in natsorted order:

```{python tidy=FALSE}
import pyranges as pr

import pandas as pd

exons = pr.data.exons()
cpg = pr.data.cpg()

for k, df in cpg:
    print(k)
    print(df.head(3))
```

If the data is unstranded, the key is just the chromosome names, but if the data
is stranded the key is a tuple of the chromosome and strand:

```{python tidy=FALSE}
for k, df in exons:
    print(k)
    print(df.head(3))
```

If you would like to iterate over the chromosomes in a stranded PyRange the idiom is

```{python tidy=FALSE}
for c in exons.chromosomes:
    print(c)
    df = exons[c].df
    print(df.head())
```


but notice that we need the .df accessor, because subsetting a PyRange always
returns a PyRange.

There are three more ways to iterate over a pyrange, namely the keys, values and
items methods. These return a list, not a custom object like the python dict.

If you want to create a new PyRange while iterating over it, the idiom is


```{python tidy=FALSE}
d = {}
for k, df in exons:
    print(k)
    d[k] = df.head(3)

new_gr = pr.PyRanges(d)
print(new_gr)
```

Note that this is basically the same as using the apply method of the PyRange,
only that the for loops are never multithreaded.
## Sorting PyRanges

pyranges are always sorted on chromosome and strand to enable faster operations.

pyranges can in addition be sorted on start and end by using the function sort:

```{python tidy=FALSE}
import pyranges as pr

import pandas as pd

from io import StringIO

cs = pr.data.chipseq()

print(cs)

cs_sorted = cs.sort()

print(cs)
```

This will sort them on Chromosome, Strand, Start and then End.

Custom sorting can be done after you are done with the PyRanges-related
functionality. Then you can extract the underlying dataframes with df and sort
it:

```{python tidy=FALSE}
df = cs_sorted.df

print(df.head())

df_sorted = df.sort_values(["Chromosome", "Start", "End"])

print(df_sorted.head(20))
```

Now the df is sorted and start and end with interleaved strands.
## Summarizing PyRanges

The summary-function gives a summary of the lengths of the intervals in a PyRange:

```{python tidy=FALSE}
import pyranges as pr

import pandas as pd

from io import StringIO

gr = pr.data.exons()

print(gr)

print(gr.summary())
```

The column `coverage_stranded` tells you how the data looks when merging all
overlapping features (taking strand into account), and `coverage_unstranded` is
the same, but all features are merged independent of their strand.

## Methods for manipulating single PyRanges

There are several methods for manipulating the contents of a PyRanges.

`merge` creates a union of all the intervals in the ranges:

```{python tidy=FALSE}
import pyranges as pr
f1 = pr.data.f1()
print(f1.merge())
```

`tssify` finds the starts of the regions (taking direction of transcription into
account). It is named -ify to make clear that it is not finding the actual tsses
(which requires metadata that signifies which intervals represent transcripts).

```{python tidy=FALSE}
f1.tssify()
print(f1.tssify(slack=5))
```

`tesify` finds the ends of the regions (taking direction of transcription into account).

```{python tidy=FALSE}
f1.tesify()
print(f1.tesify(slack=5))
```

`slack` extends the starts and ends of your interval.


```{python tidy=FALSE}
print(f1.slack(5))
```
## Intersecting Ranges

PyRanges objects can be intersected with other PyRanges to find the subset of
the genome that is contained in both. The regular intersect-method finds the
intersection of all combinations of ranges: [^1]

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.aorta()
gr2 = pr.data.aorta2()
print(gr.intersect(gr2))
```

The set_intersect method merges the intervals before finding the intersect: [^2]

```{python tidy=FALSE}
print(gr.set_intersect(gr2))
```

Both methods also take a strandedness option, which can either be `"same"`, `"opposite"` or `False`/`None`

```{python tidy=FALSE}
print(gr.set_intersect(gr2, strandedness="opposite"))
```

[^1]: This is the same behavior as bedtools intersect.
[^2]: This is the same behavior as Bioconductor GenomicRanges intersect.

The intersect method also takes a how argument, which currently accepts the
option `"containment"`, which requires that the intervals in self be completely
within the intervals in other.

```{python tidy=FALSE}
f1 = pr.data.f1()
print(f1)
f2 = pr.data.f2()
print(f2)
result = f2.intersect(f1, how="containment")
print(result)
```
## Overlapping Ranges

PyRanges objects can be overlapped with other PyRanges to report the intervals
in self that overlap with those in other.

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.aorta()
gr2 = pr.data.aorta2()
print(gr.overlap(gr2))
```

Both methods also take a strandedness option, which can either be `"same"`, `"opposite"` or `False`/`None`

```{python tidy=FALSE}
print(gr.overlap(gr2, strandedness="opposite"))
```
## Joining Ranges

You can combine all the intervals that overlap in two PyRanges objects with the join method.
If you do not use a suffix, the default `_b` is chosen.

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.aorta()
gr2 = pr.data.aorta2()
print(gr.join(gr2, suffix="_2"))
```

Both methods also take a strandedness option, which can either be `"same"`, `"opposite"` or `False`/`None`

```{python tidy=FALSE}
print(gr.join(gr2, strandedness="opposite"))
```

The join method also takes a how argument, which currently accepts the
option `"containment"`, which requires that the intervals in self be
completely within the intervals in other.

```{python tidy=FALSE}
f1 = pr.data.f1()
f2 = pr.data.f2()
print(f2.join(f1, how="containment"))
```

The join method also takes the argument new_pos which can either be `union`or
`Ã¬ntersection`. The default suffixes are `["_a", "_b"]`, but a suffixes argument
overrides this.

```{python tidy=FALSE}
print(f2.join(f1, new_pos="intersection"))
```

## Finding the closest intervals

With the nearest-method, you can search for the feature in other that is nearest
the ones in self.

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.chipseq()
gr2 = pr.data.chipseq_background()
print(gr.nearest(gr2, suffix="_Input"))
```

The nearest method takes a strandedness option, which can either be
`"same"`, `"opposite"` or `False`/`None`

```{python tidy=FALSE}
print(gr.nearest(gr2, suffix="_Input", strandedness="opposite"))
```

The nearest method also takes two variables, namely how and overlap. How can
take the values `None`, `"upstream"`, `"downstream"`, `"next"` and `"previous"`.
`"upstream"` and `"downstream"` are always in reference to the PyRange the
method is called on. `"next"` (to the right) and `"previous"` (to the left) are
most useful to implement your own custom nearest methods. The default is `None`,
which means that PyRanges looks in both directions. The overlap argument is a
bool which indicates whether you want to include overlaps or not.



```{python tidy=FALSE}
f1 = pr.data.f1()
print(f1)
f2 = pr.data.f2()
print(f2)
print(f2.nearest(f1, strandedness="opposite", how="next"))
print(f2.nearest(f1, how="upstream"))
print(f2.nearest(f1, strandedness="opposite", how="next", overlap=False))
```
## Statistics: similarity between PyRanges

PyRanges can compute a normalized Jaccard-statistic (ranging from 0 to 1) to
compute the similarities between two ranges.

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.chipseq()
gr2 = pr.data.chipseq_background()
print(gr.stats.jaccard(gr2, strandedness="same"))
```
## Statistics: spatial correlations between PyRanges

To compute the similarities between two sets of ranges which do not necessarily
overlap much, we can use the relative distance function. It describes the
relative distances between each interval in one set and the two closest intervals
in another. Any deviance from a uniform distribution is an indication of spatial
correlation.

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.chipseq()
gr2 = pr.data.chipseq_background()
print(gr.stats.relative_distance(gr2, strandedness="same"))
```
## Turning Ranges into RLEs

Ranges can be turned into dicts of run length encodings with the coverage function:

```{python tidy=FALSE}
import pyranges as pr
gr = pr.data.aorta()
print(gr)
print(gr.coverage())
print(gr.coverage(strand=True))
print(gr.coverage(strand=True, rpm=True))
```

To get the RPM-normalized coverage, use the rpm argument.

You can also create coverage for an any numeric value in your PyRanges:

```{python tidy=FALSE}
print(gr.coverage("Score"))
```
## An introduction to RLEs

Rles are runlengths - a datastructure that can compactly describe the coverage
of a genome (or some other score that is associated with each nucleotide). It is
used for efficient genomewide arithmetic operations on these scores.

```{python tidy=FALSE}
from pyrle import Rle ## or: from pyranges import Rle

runs = [10, 10, 10, 10]
values = [0, 1, 0, 0]

r1 = Rle(runs, values)
print(r1)

runs2 = [11, 9, 20]
values2 = [100, 0, 100]

r2 = Rle(runs2, values2)
print(r2)

print(r1 + r2)

print(r1 * r2)

print(r1.runs)
print(r1.values)

r1 = r1 + 5
print(r1)

print(r2 / r1)
```
## Run Length Encoding dicts

Since you need more than one run length to describe a genome with multiple
chromosomes, pyranges has a datastructure called PyRles for collections of Rles.
It can be created from a PyRanges object by invoking the coverage function.

Rledicts support the arithmetic operations +, -, /, and *.

```{python tidy=FALSE}
import pyranges as pr

gr = pr.data.chipseq()
gr_bg = pr.data.chipseq_background()

cs = gr.coverage()
print(cs)

bg = gr_bg.coverage()
print(bg)

print(cs + bg)
```

When using arithmetic operations with a stranded and an unstranded PyRle, the
stranded PyRle is automatically demoted to an unstranded PyRle.

```{python tidy=FALSE}


bg_stranded = gr_bg.coverage(strand=True)
print(bg_stranded)

print(cs + bg_stranded)
```

Like Rles, PyGRles supports arithmetic operations with numbers.

```{python tidy=FALSE}

print((0.67 + cs) * 5)
```
## Subsetting Rles

Rles can be subsetted using an integer (or a list of integers) to get the RLE value at one or more points.

```{python tidy=FALSE}
from pyrle import Rle
r = Rle([3, 2, 1, 1, 1, 1], [0, 1, 2, 1, 0, 1])
print(r)
print(r[2], r[3])
print(r[[3, 5, 7]])
```

To get the slice of one or more run lengths use a slice or a dataframe with (at
least) the columns Start and End.


```{python tidy=FALSE}
import pandas as pd
from pyrle import Rle
r = Rle([3, 2, 1, 1, 1, 1], [0, 1, 2, 1, 0, 1])

print(r[5:10])

df = pd.DataFrame({"Start": [2, 5], "End": [4, 900]})
print(df.to_csv(index=False, sep="\t"))
print(r[df], end="\n")
```

## Subsetting PyRles

Rles can be subsetted on Chromosome, Strand or Chromosome/Strand pairs

```{python tidy=FALSE}
import pyranges as pr

gr = pr.data.chipseq()
c = gr.coverage()
print(c["chr1"])
print(c["chr1", "+"])
print(c["-"])
```

To get the coverage of one or more intervals, you can use a PyRanges-object to subset the PyRles

```{python tidy=FALSE}
import pyranges as pr
f1 = pr.data.f1()
print(f1)
f1_c = f1.coverage()
print(f1_c)

print(f1_c[f1])
```
## Using multiple cores

Most PyRanges and PyRle-operations can be run in parallel. Even user-made
functions can be run in parallel using the apply or apply_pair functions.

PyRanges uses Ray, a "flexible, high-performance distributed execution
framework" to run in parallel-mode. To start Ray in parallel-mode you need to
import and initialize Ray before importing PyRanges or PyRles.

```
import ray
ray.init()
## then
import pyranges as pr
```

Now PyRanges and PyRles is running in multi-core mode.

Note: By default PyRanges uses no extra cores. Unless the data are reasonably big (at
least 10^7) number of intervals or the functions are very long-running, running
in parallel-mode is actually more time-consuming than single-core mode. Also, if
the PyRanges contains a lot of text data, there is less to be gained by using
multithreading. This is due to how strings are represented in memory in Python
and Pandas. However, this is something that will be fixed in pandas2 and then
the multithreading capabilities of PyRanges will be more useful for these kinds
of data.
## Fetching gene tracks as PyRanges

PyRanges can fetch data from UCSC, GENCODE and Ensembl through the pyranges_db add-on package.
Do `pip install pyranges_db`.

Each database contains at least two methods, namely genes and genomes. UCSC and
Ensembl also has the method chromosome_sizes.

The genes-methods all take a boolean flag `head`. If true, it only fetches a few hundred rows of data.

```{python tidy=FALSE}
import pyranges_db as pr_db

genomes = pr_db.ucsc.genomes()

print(genomes.head())

chr_sizes = pr_db.ucsc.chromosome_sizes("hg38")

print(chr_sizes.head())

genes = pr_db.ucsc.genes("hg38", head=True)

print(genes)
```
